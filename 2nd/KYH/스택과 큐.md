# 스택과 큐

# 스택

> 스택이란 데이터를 일시적으로 저장하기 위해 사용되는 자료구조로, 데이터의 입력과 출력 순서는 후입 선출 입니다. 스택에 데이터를 넣는 작업을 푸시라고 하고, 스택에서 데이터를 꺼내는 작업을 팝이라고 합니다.
> 

- 배열로 스택 만들기
    
    C언어에서는 함수를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용합니다. 예를 들어, 함수를 호출할 때는 푸시하고 함수가 실행을 종료한 뒤에 호출한 원래의 함수로 돌아갈 때 종료할 함수를 팝합니다.
    
    ```c
    void x() { }
    void y() { }
    void z() { x(); y(); }
    int main() { z(); }
    ```
    
    위와 같은 코드를 작성하게 되면 main()에서 z()함수를 호출하고, z()함수가 다시 x(), y()함수를 호출해서 스택에 저장합니다. 따라서 동작할 때는 main() → z() → x(), y()순으로 스택에 데이터를 저장합니다. 그 이후에 x(), y()함수가 작동을 종료하면 x(), y() → z() → main()순으로 데이터를 삭제하게 됩니다.
    
    x()함수가 종료되면, x()함수만 팝되게 됩니다. x()함수가 종료될 때, x(), z()함수가 동시에 팝되어 main()함수로 돌아가는 일은 없습니다.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    typedef struct {
    	int max; // 스택의 용량
    	int ptr; // 스택의 포인터
    	int *stk; // 스택의 첫 요소에 대한 포인터
    } IntStack;
    
    int Initialize(IntStack *s, int max)
    {
    	s->ptr = 0;
    	if ((s->stk = calloc(max, sizeof(int))) == NULL) {
    		s->max = 0;
    		return -1;
    	}
    	s->max = max;
    	return 0;
    }
    
    int Push(IntStack *s, int x)
    {
    	if (s->ptr >= s->max)
    		return -1;
    	s->stk[s->ptr++] = x;
    	return 0;
    }
    
    int Pop(IntStack *s, int *x)
    {
    	if (s->ptr <= 0)
    		return -1;
    	*x = s->stk[--s->ptr];
    	return 0;
    }
    
    int Peek(const IntStack *s, int *x)
    {
    	if (s->ptr <= 0)
    		return -1;
    	*x = s->stk[s->ptr - 1];
    	return 0;
    }
    
    void Clear(IntStack *s)
    {
    	s->ptr = 0;
    }
    
    int Capacity(const IntStack *s)
    {
    	return s->max;
    }
    
    int Size(const IntStack *s)
    {
    	return s->ptr;
    }
    
    int IsEmpty(const IntStack *s)
    {
    	return s->ptr <= 0;
    }
    
    int IsFull(const IntStack *s)
    {
    	return s->ptr >= s->max;
    }
    
    int Search(const IntStack *s, int x)
    {
    	int i;
    
    	for (i = s->ptr - 1; i >= 0; i--)
    		if (s->stk[i] == x)
    			return i;
    	return -1;
    }
    
    void Print(const IntStack *s)
    {
    	int i;
    
    	for (i = 0; i < s->ptr; i++)
    		printf("%d ", s->stk[i]);
    	putchar('\n');
    }
    
    void Terminate(IntStack *s)
    {
    	if (s->stk != NULL)
    		free(s->stk);
    	s->max = s->ptr = 0;
    }
    ```
    
    스택을 가장 간단하게 살펴보면 위와 같습니다. 스택으로 사용할 배열을 가리키는 포인터 stk, 스택의 최대 용량 max, 스택에 저장된 요소를 가르키는 ptr로 이루어져 있습니다. 만약에 스택에 데이터가 모두 차있다면 ptr의 크기는 max와 같고, 데이터가 하나도 없으면 0이 됩니다.
    
    - Initialize(IntStack *s, int max)
        
        이 함수는 스택의 메모리 공간을 확보하는 등의 준비 작업을 수행하는 함수이며 배열을 위한 메모리 공간을 만들 때, 스택은 비어 있어야 합니다. 따라서 ptr의 값을 0, 요소의 개수는 max인 배열 stk를 생성합니다. 데이터가 들어오면 stk[0], stk[1], stk[2] … 순서로 저장되고, stk[max - 1], stk[max - 2], stk[max - 3] … 순서로 삭제됩니다.
        
    - Push(IntStack *s, int x)
        
        데이터를 스택에 저장하는 역할을 하는 함수로 데이터를 더 이상 저장할 수 없다면 -1을 반환합니다. 스택에 여유 공간이 있다면 새로 추가할 데이터 x를 배열의 요소 stk[ptr]에 저장하고 ptr을 하나 증가시킨 뒤에 0을 반환합니다.
        
    - Pop(IntStack *s, int *x)
        
        스택에 마지막에 저장된 데이터를 제거하는 함수입니다. 팝에 성공할 경우에는 0을 반환하고, 팝을 할 데이터가 없을 경우에는 -1을 반환합니다.
        
    - Peek(const IntStack *s, int *x)
        
        스택에 마지막으로 저장된 데이터를 보는 함수입니다. 저장된 데이터를 볼 수 있는 상황이라면 0을 반환하고, 데이터를 볼 수 없는 상황(저장된 데이터가 없는 상황)이라면 -1을 반환합니다. 이 때, 데이터의 입력과 출력이 나타나지 않으므로 스택의 포인터 값은 변화하지 않습니다.
        
    - Clear(IntStack *s)
        
        스택에 쌓여있는 모든 데이터를 삭제하는 함수입니다.
        
    - Capacity(const IntStack *s)
        
        스택의 용량(max) 값을 반환하는 함수입니다.
        
    - Size(const IntStack *s)
        
        스택에 쌓여있는 데이터의 개수(ptr)을 반환하는 함수입니다.
        
    - IsEmpty(const IntStack *s)
        
        스택에 비어있으면 1, 스택에 데이터가 있다면 0을 반환합니다.
        
    - IsFull(const IntStack *s)
        
        스택에 데이터가 가득 차 있다면 1, 스택에 데이터를 더 넣을 수 있다면 0을 반환합니다.
        
    - Search(const IntStack *s, int x)
        
        임의의 데이터 값이 스택의 어느 위치에 쌓여있느지 검사하는 함수입니다. 이 함수는 ptr값이 큰 쪽에서 작은 쪽으로 선형 검색을 수행합니다. 검색에 성공하면 찾은 요소의 ptr값을 반환하고, 찾지 못했다면 -1을 반환합니다.
        
    - Print(const IntStack *s)
        
        스택 안에 있는 모든 데이터를 ptr값이 작은 순서부터 큰 순서대로 출력하는 함수입니다.
        
    - Terminate(IntStack *s)
        
        스택에 있는 모든 데이터를 삭제하고 스택을 해제하는 함수입니다.
        
    
    위에 있는 코드를 사용해서 간단한 코드를 작성하면 다음과 같습니다.
    
    ```c
    int main()
    {
    	IntStack s;
    	if(Initialize(&x, 64) == -1)
    	{
    		printf("스택 생성에 실패하였습니다.");
    		goto EXIT;
    	}
    
    	while(1)
    	{
    		int menu, x;
    		printf("현재 데이터의 수 : %d / %d\n", Size(&s), Capacity(&s));
    		printf("(1)푸쉬 (2)팝 (3)피크 (4)출력 (0) 종료 : ");
    		scanf("%d", &menu);
    
    		if(menu == 0) break;
    		switch(menu) {
    		case 1:
    		printf("데이터 : ");
    		scanf("%d", &x);
    		if(Push(&x, x) == -1)
    			printf("\a오류 : 푸쉬에 실패하였습니다.");
    		break;
    
    		case 2:
    		if(Pop(&s, &x) == -1)
    			printf("\a오류 : 팝에 실패하였습니다.");
    		else
    			printf("팝의 데이터는 &d입니다. \n", x);
    		break;
    
    		case 3:
    		if(Peek(&s, &x) == -1)
    			printf("\a오류 : 피크에 실패하였습니다.")
    		else
    			printf("피크 데이터는 %d입니다.\n", x);
    		break;
    
    		case 4:
    		Print(&s);
    		break;
    		}
    
    		Terminate(&s);
    	}
    	EXIT : return 0;
    }
    ```
    

## 큐

> 스택은 큐와 같이 데이터를 일시적으로 저장하는 자료구조입니다. 하지만 가장 먼저 넣은 데이터를 가장 먼저 삭제하는 점이 스택과의 차이점입니다. 큐에 데이터를 넣는 작업을 인큐(enqueue)라 하고, 데이터를 꺼내는 작업을 (dequeue)라고 합니다.
> 

- 링 버퍼
    
    먼저 큐를 만들기 전에 배열 요소를 앞쪽으로 옮기지 않기 위해서 링 버퍼(ring buffer)를 구현해 보겠습니다. 링 버퍼는 배열의 처음과 끝이 연결되어 있는 자료구조입니다. 이 때 논리적으로 어떤 요소가 처음이고 마지막인지 확인하는 변수를 프론트(front)와 리어(rear)라고 합니다.
    
    ```c
    #include <stdio.h>
    
    int main()
    {
        int data[10] = { 0 };
        int front = 0, rear = 0, state = 0, menu;
        while (1)
        {
            printf("1.input 2.print 3.shutdown : ");
            scanf("%d", &menu);
            switch(menu)
            {
                case 1:
                printf("%d : ", rear);
                scanf("%d", data + rear);
                ++rear;
                if(rear > 9)
                {
                    rear = 0;
                    state = 1;
                }
                if(state)
                    front = rear;
                break;
    
                case 2:
                printf("front : %d, rear : %d)\n", front, rear);
                for(int i = front; state ? i < rear + 10 : i % 10 != rear; ++i)
                    printf("%d\t", data[i % 10]);
                printf("\n");
                break;
    
                case 3:
                return 0;
            }
        }
    }
    ```
    
    이렇게 링 버퍼를 사용하면 오래된 데이터는 자동으로 삭제되게 하면서 새로운 데이터는 자동으로 저장할 수 있습니다.
    
- 링 버퍼로 큐 만들기
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    typedef struct {
    	int max;
    	int num;
    	int front;
    	int rear;
    	int *que;
    } IntQueue;
    
    int Initialize(IntQueue *q, int max)
    {
    	q->num = q->front = q->rear = 0;
    	if ((q->que = calloc(max, sizeof(int))) == NULL) {
    		q->max = 0;
    		return -1;
    	}
    	q->max = max;
    	return 0;
    }
    
    int Enque(IntQueue *q, int x)
    {
    	if (q->num >= q->max)
    		return -1;
    	else {
    		q->num++;
    		q->que[q->rear++] = x;
    		if (q->rear == q->max)
    			q->rear = 0;
    		return 0;
    	}
    }
    
    int Deque(IntQueue *q, int *x)
    {
    	if (q->num <= 0)
    		return -1;
    	else {
    		q->num--;
    		*x = q->que[q->front++];
    		if (q->front == q->max)
    			q->front = 0;
    		return 0;
    	}
    }
    
    int Peek(const IntQueue *q, int *x)
    {
    	if (q->num <= 0)
    		return -1;
    	*x = q->que[q->front];
    	return 0;
    }
    
    void Clear(IntQueue *q)
    {
    	q->num = q->front = q->rear = 0;
    }
    
    int Capacity(const IntQueue *q)
    {
    	return q->max;
    }
    
    int Size(const IntQueue *q)
    {
    	return q->num;
    }
    
    int IsEmpty(const IntQueue *q)
    {
    	return q->num <= 0;
    }
    
    int IsFull(const IntQueue *q)
    {
    	return q->num >= q->max;
    }
    
    int Search(const IntQueue *q, int x)
    {
    	int i, idx;
    
    	for (i = 0; i < q->num; i++) {
    		if (q->que[idx = (i + q->front) % q->max] == x)
    			return idx;
    	}
    	return -1;
    }
    
    void Print(const IntQueue *q)
    {
    	int i;
    
    	for (i = 0; i < q->num; i++)
    		printf("%d ", q->que[(i + q->front) % q->max]);
    	putchar('\n');
    }
    
    void Terminate(IntQueue *q)
    {
    	if (q->que != NULL)
    		free(q->que);
    	q->max = q->num = q->front = q->rear = 0;
    }
    
    ```
    
    큐로 사용할 배열을 que를 통해서 만들고, max를 통해서 큐의 최대 용량을 설정합니다. front, rear 변수를 통해서 링 버퍼의 논리 구조를 설정하고, num을 통해서 현재 있는 데이터의 개수를 확인합니다. front, rear를 통해서는 큐에 쌓여있는 데이터의 개수를 알 수 없기 때문에 데이터의 개수를 관리하기 위한 변수가 하나 더 필요합니다.
    
    - Initialize(IntQueue *q, int max)
        
        큐를 구현하기 위한 배열의 메모리 공간 확보 등을 준비하는 함수입니다. 이 때 max값을 받아서 큐의 사이즈를 설정합니다.
        
    - Enque(IntQueue *q, int x)
        
        큐에 데이터를 인큐하는 함수입니다. 인큐에 성공하면 0을 반환하고, 인큐에 실패하면 -1을 반환합니다. 그러나 만약에 rear의 값이 max이상이 되면 할당하지 않은 주소값을 참조하게 되어 오류가 발생하기 때문에 해당 현상을 대비하기 위해서 rear의 값이 max와 같아지면 rear를 다시 0으로 초기화해줍니다.
        
    - Deque(IntQueue *q, int *x)
        
        큐에서 데이터를 디큐하는 함수입니다. 디큐에 성공하면 0을 반환하고, 큐에 데이터가 없어서 디큐에 실패하면 -1을 반환합니다. 여기서도 인큐와 마찬가지로 front의 값이 12를 넘어가면 할당하지 않은 주소값을 참조하게 되어 오류가 발생합니다. 따라서 인큐와 마찬가지로 front의 값이 max와 같아지면 다시 0으로 초기화해줍니다.
        
    - Peek(const IntQueue *q, int *x)
        
        맨 앞의 데이터(디큐에서 꺼낼 데이터)를 보는 함수로 데이터를 꺼내지 않아서 데이터에 영향을 주진 않습니다. 피크에 성공하면 0, 실패하면 -1을 반환합니다.
        
    - Clear(IntQueue *q)
        
        큐에 저장된 모든 데이터를 삭제하는 함수입니다.
        
    - Capacity(const IntQueue *q)
        
        최대 용량을 반환하는 함수입니다.
        
    - Size(const IntQueue *q)
        
        큐의 데이터 개수(num)을 반환하는 함수입니다.
        
    - IsEmpty(const IntQueue *q)
        
        큐가 비어 있는지 확인하는 함수입니다.
        
    - IsFull(const IntQueue *q)
        
        큐가 가득 차있는지 확인하는 함수입니다.
        
    - Search(const IntQueue *q, int x)
        
        큐의 데이터에 x와 같은 값이 있는지 확인하는 함수입니다. 데이터를 찾을 때는 선형 검색을 수행하고 배열의 첫 요소부터 찾는 것이 아니라 front값부터 검색을 수행합니다. 같은 데이터를 찾으면 데이터가 저장되어 있는 인덱스를 반환하고, 만약에 값이 데이터 안에 없다면 -1을 반환합니다.
        
    - Print(const IntQueue *q)
        
        큐의 모든 데이터를 front부터 rear까지 출력하는 함수입니다.
        
    - Terminate(IntQueue *q)
        
        메모리 공간에 할당한 큐를 해제하는 함수입니다.
        
    
    위에 있는 코드를 사용해서 간단한 코드를 작성하면 다음과 같습니다.
    
    ```c
    int main()
    {
        IntQueue que;
    
        if(Initialize(&que, 64) == -1)
        {
            printf("ERROR : Que Initializing Failed");
            return 0;
        }
    
        while(1)
        {
            int menu, x;
    
            while(1)
            {
                printf("Data capacity : %d / %d\n", Size(&que), Capacity(&que));
                printf("1.Enqueue 2.Dequeue 3.Peek 4.Print 0.Shutdown : ");
                scanf("%d", &menu);
    
                if(menu == 0) break;
                switch(menu)
                {
                    case 1:
                    printf("data : ");
                    scanf("%d", &x);
                    if(Enque(&que, x) == -1) printf("\a ERROR : Euqueue Failed\n");
                    break;
    
                    case 2:
                    if(Deque(&que, &x) == -1) printf("\a ERROR : Dequeue Failed\n");
                    else printf("Dequeued data : %d \n", x);
                    break;
    
                    case 3:
                    if(Peek(&que, &x) == -1) printf("ERROR : Peek failed\n");
                    else printf("Peek data : %d \n", x);
                    break;
    
                    case 4:
                    Print(&que);
                    break;
    
                }
            }
            Terminate(&que);
    
            return 0;
        }
    }
    ```