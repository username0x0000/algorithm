# 재귀 알고리즘

# 재귀의 기본

> 어떤 사건이 자기 자신을 포함하고 다시 자기 자신을 사용하여 정의될 때 재귀적(recursive)이라고 합니다.
> 

- 재귀적 정의의 예시
    1. 1은 자연수입니다.
    2. 자연수 n의 바로 다음 수도 자연수입니다.
    
    위의 재귀적 정의를 사용하면 무한으로 존재하는 자연수를 위의 두 문장으로 간단하게 정의할 수 있습니다. 프로그래밍을 할 때에도 이와 마찬가지로 재귀를 사용하면 간단하게 코딩을 할 수 있습니다.
    
- 재귀적 코딩의 예시
    
    ```c
    int factorial(int n)
    {
    	if(n > 0) return n * factorial(n - 1);
    	else return 1;
    }
    ```
    
    위의 함수는 호출 방식 factorial(3) → factorial(2) → factoral(1) → factorial(0) 순으로 계속해서 자기 자신을 호출합니다. factorial(1)은 factorial(0)에서 넘겨받은 1을 곱해서 factorial(2)로 넘겨주고, factorial(2)는 다시 자신이 받은 1을 곱해서 factorial(3)으로 넘겨줍니다. 이러면 최종적으로 3 * 2 * 1 * 1의 형태가 되어서 팩토리얼의 형태를 취할 수 있습니다.
    
    ```c
    int gcd(int x, int y)
    {
    	if(y == 0) return x;
    	else return gcd(y, y % x);
    }
    ```
    
    같은 방식으로 유클리드 호제법을 활용해서 최대 공약수를 구하는 식의 코드를 작성할 수도 있습니다.
    

# 재귀 알고리즘 분석

> 재귀 알고리즘을 분석하기 위한 방식으로는 하향식(top down)분석과 상향식(bottom top) 분석이 있습니다.
> 

- 아래의 코드와 같이 함수 안에서 재귀 호출을 2회 이상 실행하는 함수를 순수하게(genuinely)재귀적이라고 합니다. 이러한 함수를 하향식과 상향식 두 가지 방식으로 분석해보겠습니다.
    
    ```c
    void recur(int n)
    {
    	if(n > 0)
    	{
    		recur(n - 1);
    		printf("%d ", n);
    		recur(n - 2);
    	}
    }
    ```
    
    - 하향식 분석의 경우
        
        매개변수 n으로 4를 전달하면 recur()함수는 아래 과정을 순서대로 실행합니다.
        
        1. recur(3)을 실행합니다.
        2. 4를 출력합니다.
        3. recur(2)를 실행합니다.
        
        그러나 여기서 4를 출력하기 전에 recur(3)이 실행이 종료되어야 하고, 또 이 함수는 recur(2) 함수를 호출하기 때문에 아주 복잡한 방식으로 진행됩니다.
        
        1. recur(4)가 recur(3)호출
            1. recur(3)이 recur(2)호출
                1. recur(2)이 recur(1)호출
                    1. recur(1)이 recur(0)호출
                        1. recur(0)종료
                    2. recur(1)이 1출력
                    3. recur(1)이 recur(-1)호출
                        1. recur(-1)종료
                    4. recur(1)종료
                2. recur(2)가 2출력
                    1. recur(2)이 recur(0)호출
            
            …
            
        
        이처럼 가장 위 쪽에 위치한 함수의 호출부터 시작해 계단식으로 자세히 내려가는 분석 기법을 하향식 분석이라고 합니다. 그러나 위의 함수 같은 경우는 같은 호출이 여러 번 나올 수 있기 때문에 하향식 분석이 반드시 효율적이라고 말할 수는 없습니다.
        
    - 상향식 분석의 경우
        
        상향식 분석의 경우는 아래쪽부터 쌓아 올리며 분석하는 방식이기 때문에 recur(1)부터 시작합니다.
        
        1. recur(1)
            1. recur(0) 호출 → 종료
            2. 1 출력
            3. recur(-1) 호출 → 종료
        2. recur(2)
            1. recur(1) 실행
            2. 2 출력
            3. recur(0) 실행
    
    위와 같은 방식으로 계산하면 다음과 같이 계산이 실행됩니다.
    
    | recur(4) | recur(3) | recur(2) | recur(1) | recur(0) | recur(-1) |
    | --- | --- | --- | --- | --- | --- |
    | 1 2 3 1 4 1 2 | 1 2 3 1 | 1 2 | 1 | 종료 | 종료 |
    
- 재귀 알고리즘의 비재귀적 표현
    
    그러나 재귀 함수의 경우 함수의 원래 호출 위치를 스택에 저장하기 때문에 위와 같은 함수가 데이터를 많이 포함하고 있을 경우, 스택 오버 플로가 발생할 수 있다. 이러한 경우를 예방하기 위해서는 함수를 한 번이라도 덜 호출해야 하기 때문에 꼬리 재귀를 제거하는 방식으로 코드를 작성하는 것이 좋다.
    
    recur()함수의 경우, n - 2로 호출하는 함수는 결과적으로 n의 값에 - 2를 한 뒤에 처음으로 돌아가는 형태이기 때문에 goto문법을 사용해서 처음으로 돌아가면 처음의 의도와 같은 결과값을 내면서 함수를 한 번 덜 호출할 수 있다. 이런 식으로 같은 내용을 반복할 경우, 함수의 해당 부분으로 돌아가서 그 부분만 실행시키는 것이 재귀 알고리즘의 비재귀적 표현이다.
    

# 하노이의 탑

> 쌓아놓은 원반을 최소의 횟수로 옮기기 위한 알고리즘에 대해서 알아봅시다.
> 

- 하노이의 탑
    
    하노이의 탑은 작은 원반이 위에 큰 원반이 아래에 위치할 수 있도록 원반을 3개의 기둥 사이에서 옮기는 문제입니다. 원반이 2개인 경우라면, 1번 원반을 옆으로 옮긴 다음에 2번 원반을 목표 위치로 옮기고, 그 위에 1번을 놓으면 됩니다. 이러한 원리를 원반이 3개인 경우에 대해서 적용해보면 1, 2번을 같은 그룹으로 보고, 3번을 목표 위치에 옮긴 다음에 1, 2번을 옮기면 됩니다. 4개인 경우라면 1, 2, 3번을 같은 그룹으로 보고 4번을 목표 위치에 옮긴 다음에 1, 2, 3번을 옮기면 됩니다.
    
    하노이의 탑을 구현하는 방식은 다음과 같습니다.
    
    ```c
    #include <stdio.h>
    
    void move(int no, int x, int y)
    {
    	if(no > 1)
    		move (no - 1, x, 6 - x - y);
    	printf("원반[%d]번을 %d번 기둥에서 %d번 기둥으로 옮김\n", no, x, y);
    
    	if(no > 1)
    		move(no - 1, 6 - x - y, y);
    }
    
    int main()
    {
    	int n;
    	printf("하노이의 탑\n 원반 개수 : ");
    	scanf("%d", &n);
    	move(n, 1, 3);
    	
    	return 0;
    }
    ```
    
    이 프로그램은 기둥 번호를 정수 1, 2, 3으로 나타냅니다. 기둥 번호의 합이 6이므로 중간 기둥은 6 - x(시작 기둥) -y(목표 기둥)으로 나타낼 수 있습니다 원반은 n개 이므로, move함수는 다음과 같은 동작을 실행합니다.
    
    1. 바닥 원반을 제외한 그룹을 시작기둥에서 중간 기둥으로 옮깁니다.
    2. 바닥 원반을 시작 기둥에서 목표 기둥으로 옮겼음을 출력합니다.
    3. 바닥 원반을 제외한 그룹을 중간 기둥에서 목표 기둥으로 옮깁니다.
    
    여기서 동작 1, 3은 재귀 호출에 의해서 실행됩니다. 예를 들어서 n이 3이라면, move()함수의 동작은 다음과 같이 말할 수 있습니다.
    
    1. move(3, 1, 3)
        1. move(2, 1, 2)
            1. move(1, 1, 3)
                1. 1번 원반을 시작 기둥에서 목표 기둥으로 이동
            2. 2번 원반을 시작 기둥에서 중간 기둥으로 이동
            3. move(1, 3, 2)
                1. 1번 원반을 목표 기둥에서 중간 기둥으로 이동
        2. 원반 3번을 시작 기둥에서 목표 기둥으로 이동
        3. move(2. 2. 3)
            1. move(1, 2, 1)
                1. 1번 원반을 중간 기둥에서 시작 기둥으로 이동
            2. 2번 원반을 중간 기둥에서 목표 기둥으로 이동
            3. move(1, 1, 3)
                1. 1번 원반을 시작 기둥에서 목표 기둥으로 이동

# 8퀸 문제

> 8퀸 문제란 서로 공격하여 잡을 수 없는 퀸 8개를 8 x 8 체스 판에 놓는 문제입니다.
> 

- 일단 퀸을 놓는 조합부터 생각해 보겠습니다.
    - 퀸을 놓을 수 있는 방법은 64칸의 체스칸 중에서 하나를 선택할 확률과 같습니다.
        
        64 x 63 x 62 x 61 x 60 x 59 x 58 x 57 = 178,462,987,637,760
        
    - 같은 열에 있는 퀸은 퀸을 잡을 수 있으므로, 각 열에는 퀸이 하나만 있어야 합니다.
        
        8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 = 16,777,216
        
    - 또한 같은 행에 있는 퀸은 퀸을 잡을 수 있으므로, 각 행에도 퀸은 하나만 배치되어야 합니다.
        
        8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 = 16,777,216
        

- 분할 해결법과 분기 한정법
    - 가지 뻗기
        
        pos[i] = j로 해서 i를 열, j를 행으로 생각해보겠습니다. 예를 들어서 (3, 4)라면 pos[3] = 4의 형식으로 나타냅니다. 이 때 set()함수는 각 열에 1퀸을 1개만 배치하는 8가지 조합을 생성하는 재귀 함수로 만듭니다. set()함수의 인자를 하나씩 더해서 주면, 모든 열에 퀸을 하나씩만 배치할 수 있는 조합이 생성됩니다. 이러한 방식으로 계속해서 반복하면 총 16,777,216개의 결과가 나옵니다.
        
        ```c
        set(int i)
        {
        	for int j = 0; j < 8; ++j)
        	{
        		pos[i] = j;
        		if(i == 7) print();
        		else set(i + 1);
        	}
        }
        ```
        
        이러한 방식으로 문제를 세분화하여 원래 문제를 해결하는 방식을 분할 해결법이라고 합니다.
        
    - 한정 조작
        
        가지 뻗기의 방식으로는 퀸을 배치하는 조합을 나열할 수는 있지만 8퀸 문제의 답을 얻을 수는 없습니다. 따라서 앞에서 분기를 한정하기 위해 정했던 규칙(각 행에 퀸을 하나만 배치합니다)를 적용시키면 됩니다. 이러한 방식으로 각 열에 배치할 때, 같은 행에 배치가 되면 그 분기를 생략(set()함수를 재귀적으로 호출하지 않게)합니다. 분기를 설정하기 위한 배열로 flag를 설정하고, flag[j]가 0이라면 해당 행에 퀸을 놓을 수 있습니다. 만약에 flag[j]가 0이 아니라면 따로 set()함수를 재귀호출하지 않고 생략합니다.
        
        ```c
        set(int i)
        {
        	for int j = 0; j < 8; ++j)
        	{
        		if(!flag[j])
        		{
        			pos[i] = j;
        			if(i == 7) print();
        			else
        			{
        				set(i + 1);
        				flag[j] = 1;
        				set(i + 1);
        				flag[j] = 0;
        			}
        		}
        	}
        }
        ```
        
        이런 식으로 더 이상 해가 나오지 않을 것 같은 분기를 삭제하여 문제를 해결하는 방식을 분기 한정법이라고 합니다.
        
- 8퀸 문제의 해답
    
    이제 같은 행, 같은 열에 퀸을 배치하지 않는 알고리즘의 작성은 끝났습니다. 그러나 퀸은 대각선 방향으로도 갈 수 있기 때문에 해당 분기에 대해서도 한정 조작을 해주어야 합니다. 대각선 방향에 퀸이 없는지 확인하기 위해서는 각각의 대각선을 담당하는 새로운 배열 2개를 선언해주어야 합니다. 우측 상단에서 좌측 하단으로 내려가는 대각선에서는 행과 열의 합이 항상 일정하다. 따라서 flag_b[i + j]가 0이 아니라면, 해당 값을 가진 칸에는 더 이상 퀸을 배치하지 않습니다. 반대로 좌측 상단에서 우측 하단으로 내려가는 대각선에서는 행과 열의 차가 항상 일정하다. 따라서 flac_c[i - j + 7]가 0이 아니라면, 해당 값을 가진 칸에도 더 이상 퀸을 배치하지 않으면 됩니다.
    
    ```c
    set(int i)
    {
    	for int j = 0; j < 8; ++j)
    	{
    		if(!flag[j] && flag_b[i + j] && flac_c[i - j + 7])
    		{
    			pos[i] = j;
    			if(i == 7) print();
    			else
    			{
    				set(i + 1);
    				flag[j] = 1;
    				set(i + 1);
    				flag[j] = 0;
    			}
    		}
    	}
    }
    ```
    

- 유클리드 호제법
    
    유클리드 호제법이란 두 정수를 직사각형의 두 변의 길이라고 생각할 때, 그 안에 들어갈 수 있는 최대 크기의 정사각형의 한 변의 길이를 구하는 방식으로 최대 공약수를 구하는 방식을 말합니다. 예를 들어서 짧은 변의 길이를 한 변으로 하는 정사각형으로 직사각형을 채운 뒤에 남은 직사각형에 대해서도 같은 작업을 반복하면 결국 정사각형으로만 도형을 채울 수 있게 되는데 이 때 만들어진 정사각형의 한 변의 길이가 최대공약수입니다.