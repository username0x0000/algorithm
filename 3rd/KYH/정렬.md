# 정렬

## 정렬의 기본 요소

> 정렬은 핵심 항목(KEY)의 대소 관계에 따라 데이터 집합을 일정 순서로 줄지어 늘어서도록 바꾸는 작업을 말합니다.  이 알고리즘을 사용하여 데이터를 정렬하면 검색을 더 수비게 할 수 있습니다.
> 

- 정렬 알고리즘의 안정성
    
    같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되면 안정된 정렬이라고 하고, 순서가 유지되지 않는다면 안정되지 않은 알고리즘이라고 합니다. 예를 들어서, 성적 순으로 학생을 나열할 경우, 학번을 고려하여 학번이 빠른 순서가 앞에 오면 안정적인 정렬이라고 하고, 학번이 무작위로 정렬되면 안정되지 않은 알고리즘이라고 합니다.
    

- 내부 정렬과 외부 정렬
    
    하나의 배열에서 작업할 수 있는 경우에는 내부 정렬(internal sorting)을 사용하고, 하나의 배열에서 작업할 수 없는 경우에는 외부 정렬(external sorting)이라고 합니다. 외부 정렬은 내부 정렬의 응용으로서, 외부 정렬을 구현하려면 작업을 위한 파일 등이 필요하고 알고리즘도 복잡합니다. 따라서 이제부터 알아볼 정렬은 모두 내부 정렬에 대한 것입니다.
    

- 정렬 알고리즘의 핵심 요소는 교환, 선택, 삽입이며 대부분의 정렬 알고리즘은 이 세 가지 요소를 응용하여 구성됩니다.

## 버블 정렬

> 버블 정렬은 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복합니다.
> 

- 기본적인 버블 정렬
    
    예를 들어서 arr = {1, 5, 2, 3, 6, 8, 7, 9, 4};라는 배열이 있다고 가정하면 다음 순서와 같이 정렬됩니다.
    
    1. 가장 끝에 있는 9, 4를 비교합니다. 9는 4보다 크기 때문에 9와 4의 위치가 변경됩니다.
        
        arr = {1, 5, 2, 3, 6, 8, 7, 4, 9};
        
    2. 그 앞으로 한 칸 이동하여 7, 4를 비교합니다. 7은 4보다 크기 때문에 7과 4의 위치가 변경됩니다.
        
        arr = {1, 5, 2, 3, 6, 8, 4, 7, 9};
        
    3. …
    
    위의 과정을 반복하여 가장 작은 요소가 맨 처음으로 이동할 때까지 반복합니다. 따라서 위의 과정을 8까지 반복한 결과는 arr = {1, 2, 5, 3, 4, 6, 8, 7, 9};가 됩니다. 여기서 비교, 교환 작업을 패스(pass)라고 하고, 요소의 개수가 n개인 배열에서 n - 1회의 배열 작업이 일어나게 됩니다.이렇게 한 번의 작업이 끝나면 배열의 2번째 요소부터 9번째 요소까지 비교하는 작업을 비교하고, 그 다음에는 3번째 요소부터 9번째 요소까지 비교하는 식으로 반복적으로 수행합니다. 이런 식으로 패스를 k회 수행하면 앞 쪽의 요소가 k번까지 정렬됩니다. 따라서 위의 알고리즘을 프로그램으로 작성하면 다음과 같이 작성됩니다.
    
    ```c
    #define swap(type, x, y) do { type t = x; x = y; y = t; } while(0)
    
    void bubble(int a[], int n)
    {
    	for(int i = 0; i < n - 1; ++i)
    		for(int j = n - 1; j > i; --j)
    			if(a[j - 1] > a[j])
    				swap(int, a[j - 1], a[j]);
    }
    ```
    
    위의 정렬 알고리즘의 경우, 서로 이웃한 요소에 대해서만 교환하므로 이 정렬 알고리즘은 안정적이라고 할 수 있습니다. 비교 횟수는 n(n - 1) / 2가 되고, 실제 요소를 교환하는 횟수는 배열의 요솟값에 더 많이 영향을 받기 때문에 교환 횟수의 평균값은 비교 횟수의 절반인 n(n - 1) / 4회가 됩니다. 또한 swap()함수 안에서 값의 이동이 3회 발생하므로, 이동 횟수의 평균은 3n(n - 1) / 4가 됩니다.
    
- 버블 정렬의 개선(1)
    
    위의 방식으로 동작을 시키면 5번 수행한 뒤의 결과값이 {1, 2, 3, 5, 6, 7, 8, 9}가 되어도 프로그램이 중단되지 않고 계속 실행되기 때문에 비효율적인 동작을 반복합니다. 따라서 이 프로그램을 좀 더 효율적으로 동작시키기 위한 알고리즘을 구상해 보겠습니다.
    
    만약에, 패스를 실행할 때, 요소 교환 횟수가 0이라면 모든 값이 정렬되었다는 신호입니다. 따라서 이러한 중단점을 만들어서 실행하면 비교 연산이 생략되어 더 짧은 시간에 정렬을 마칠 수 있습니다. 이러한 방식으로 코드를 작성하면 다음과 같습니다.
    
    ```c
    #define swap(type, x, y) do { type t = x; x = y; y = t; } while(0)
    
    void bubble(int a[], int n)
    {
    	for(int i = 0; i < n - 1; ++i)
    	{
    		int exchg = 0;
    		for(int j = n - 1; j > i; --j)
    		{
    			if(a[j - 1] > a[j])
    			{
    				swap(int, a[j - 1], a[j]);
    				++exchg;
    			}
    		}
    	}
    }
    ```
    

- 버블 정렬의 개선(2)
    
    다시 초기의 배열 arr = {1, 5, 2, 3, 6, 8, 7, 9, 4};에 대해서 버블 정렬을 수행해 보겠습니다. 만약에 어떤 배열의 요소가 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞 쪽의 요소는 이미 정렬을 마친 상태라고 생각해도 괜찮습니다. 예를 들어서, 패스를 두 번 실행한 이후의 결과는 arr = {1, 2, 3, 5, 4, 6, 7, 8, 9};가 됩니다. 여기서 2, 3은 이미 정렬을 마쳤기 때문에 3을 더 이상 정렬할 필요는 없습니다. 따라서 이 이후에는 4번째 요소부터 9번째 요소까지만 비교 수행하면 됩니다. 이것을 코드로 작성하면 다음과 같습니다.
    
    ```c
    #define swap(type, x, y) do { type t = x; x = y; y = t; } while(0)
    
    void bubble(int a[], int n)
    {
    	int k = 0;
    	while(k < n - 1)
    	{
    		int last = n - 1;
    		for(int i = n - 1; i > k; --i)
    		{
    			if(a[j - 1] > a[j])
    			{
    				swap(int, a[j - 1], a[j]);
    				last = j;
    			}
    		}
    		k = last;
    	}
    }
    ```
    
    last는 각 패스에서 마지막으로 교환한 두 요소 가운데 오른쪽 요소의 인덱스를 저장합니다. 교환을 수행할 때마다 오른쪽 요소의 인덱스 값을 last에 저장하고, 다음번 패스에서 마지막으로 비교할 요소는 a[k]와 a[k + 1]이 되기 떄문에 위와 같이 더 이상 교환을 수행하지 않아도 되는 수에 대해서는 무시할 수 있습니다. 이 때, 첫 번째 패스에서는 모든 요소를 검사해야 하기 때문에 k의 값은 0으로 초기화되어야 합니다.
    
- 버블 정렬의 개선(3)
    
    만약에 어떤 배열 arr = {9, 1, 2, 3, 4, 5, 6, 7, 8}에 대하여 이 배열은 나머지는 정렬이 끝났지만, 9가 매번 자리를 이동하기 때문에 패스를 8번 수행해야 합니다. 따라서 이러한 경우에 더 빨리 정렬을 마칠 수 있도록 홀수 번째 패스는 가장 작은 요소를 맨 앞으로 옮기고, 짝수 번째 패스는 가장 큰 요소를 뒤로 보내는 방식으로 정렬을 수행하는 코드를 작성하면 다음과 같습니다.
    
    ```c
    int exc = 0;
    #define swap(type, x, y) do { type t = x; x = y; y = t; ++exc; } while(0)
    
    void bubble(int a[], int n)
    {
    	for(int i = 0; i < n - 1; ++i)
        {
            if(i % 2)
            {
                for(int j = n - 1; j >= 0; --j)
                    if(a[j] > a[j] + 1)
                        swap(int, a[j - 1], a[j]);
            }
            else
            {
                for(int j = i; j < n - 1; ++j)
                    if(a[j] > a[j] + 1)
                        swap(int, a[j - 1], a[j]);
            }
        }
    }
    
    int main()
    {
        int arr[] = {9, 1, 2, 3, 4, 5, 6, 7, 8};
        bubble(arr, 9);
        for(int i = 0; i < 9; ++i)
            printf("%d ", arr);
    }
    ```
    
    이 정렬을 양방향 버블 정렬이나 칵테일, 셰이커 정렬이라고 부르기도 합니다.
    

## 단순 선택 정렬

> 단순 선택 정렬(straight selection sort)은 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘입니다.
> 

- 기본적인 단순 선택 정렬
    
    예를 들어 배열 arr = {3, 4, 2, 5, 1}이라는 배열이 있다고 가정하면, 1을 찾은 다음에 1의 위치에 있는 3과 위치를 교환합니다. 그러면 결과물은 {1, 4, 2, 5, 3}이 되고, 계속해서 작은 요소를 찾아서 해당하는 위치에 넣어줍니다. 이 과정을 n - 1회  구현하면 정렬이 완료됩니다. 이 과정을 코드로 작성하면 다음과 같습니다.
    
    ```c
    #define swap(type, x, y) do { type t = x; x = y; y = t; ++exc; } while(0)
    
    void selection(int a[], int n)
    {
        for(int i = 0; i < n - 1; ++i)
        {
            int min = i;
            for(int j = i + 1; j < n; ++j)
                if(a[j] < a[min])
                    min = j;
            swap(int, a[i], a[min]);
        }
    }
    ```
    
- 단순 선형 정렬 알고리즘의 요솟값을 비교하는 횟수는 n(n - 1) / 2회 입니다. 그런데 이 정렬 알고리즘은 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 않습니다. 따라서 키 값을 제외한 순서는 유지되지 않을수도 있습니다.

## 단순 삽입 정렬

> 단순 삽입 정렬(straight insertion sort)은 선택한 요소를 그 보다 더 앞쪽의 알맞은 위치에 삽입하는 작업을 반복하여 정렬하는 알고리즘입니다. 단순 선택 정렬은 가장 작은 요소만을 변경할 수 있지만, 단순 삽입 정렬의 경우
> 

- 기본적인 단순 삽입 정렬
    
    아직 정렬되지 않은 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입합니다. 예를 들어서 배열 arr = {5, 3, 1, 2, 4}라는 것에 대하여 3은 5보다 앞 쪽에 삽입이 되어야 하므로, 3과 5의 위치가 바뀌게 됩니다. 그러나, C언어에서는 ‘배열의 요소의 알맞은 위치에 삽입한다’라는 게 존재하지 않습니다. 따라서 알맞은 위치에 삽입한다는 것의 의미는 다음과 같습니다. 앞에서 살펴봤듯이 왼쪽에 이웃한 요소가 선택한 요소보다 크면 그 값을 대입하고 앞으로 이동하면서 이 작업을 반복합니다. 그러다가 해당하는 값의 요소를 만나게 되면 그 앞은 검사할 필요가 없으므로 두 요소의 값을 교환합니다.
    
    따라서 작업은 다음과 같이 순서로 성립합니다.
    
    1. 정렬된 열의 왼쪽 끝에 도달합니다.
    2. 해당 값과 작거나 같은 key를 갖는 항목을 발견합니다.
    
    이 과정을 마치고 난 다음에 두 요소의 값을 교환합니다.
    

## 셸 정렬

> 셸 정렬은 단순 삽입 정렬의 장점은 살리고 단점은 보완하여 좀 더 빠르게 정리하는 알고리즘입니다.
> 

- 기본적인 셸 정렬
    
    예를 들어서 배열 arr = {1, 2, 3, 4, 5, 0, 6}에 대해서 단순 삽입 정렬을 수행한다고 가정합니다. 단순 삽입 정렬의 경우, 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라지지만, 삽입할 위치가 멀리 떨어져 있으면 교환해야하는 횟수가 많아져서 작동이 느려집니다.
    
    따라서 셸 정렬은 교환해야 하는 횟수를 줄이기 위해서 정렬할 배열의 요소를 n칸만큼 떨어진 그룹으로 나눠  각 그룹별로 단순 삽입 정렬을 수행하고 그 그룹을 합치면서 정렬을 반복합니다. 여기서의 그룹을 묶는 수에 따라서 n-정렬이라고 합니다. 예를 들어서, arr = {8, 1, 4, 2, 7, 6, 3, 5}라는 배열에 대해서 셸 정렬을 해보겠습니다.
    
    1. 일단 처음으로 4-정렬을 합니다. 그러면 {8, 7}, {1, 6}, {4, 3}, {2, 5}의 그룹으로 arr이 나누어지게 되는데 이 값을 정렬하면 arr = {7, 1, 3, 2, 8, 6, 4, 5}가 됩니다.
    2. 4-정렬을 마친 배열에 대해서 다시 2-정렬을 해줍니다. 그러면 그룹은 {7, 3, 8, 4}와 {{1, 2, 6, 5}가 되는데 이 값을 정렬하면 arr = {3, 1, 4, 2, 7, 5, 8, 6}이 됩니다.
    3. 마지막으로 1-정렬을 해주게 되면 arr = {1, 2, 3, 4, 5, 6, 7, 8}이 되어 정렬이 끝나게 됩니다.
    
    셸 정렬 과정에서 수행하는 각각의 정렬을 h-정렬이라고 하고, 위의 경우에서는 h의 값이 4, 2, 1로 감소하면서 7회의 정렬로 셸 정렬이 완료되었습니다. 이처럼 정렬이 하나도 되지 않은 정렬에 대해서 단순 삽입 정렬으 그냥 적용하는 것이 아니라 4-정렬, 2-정렬로 조금이라도 정렬이 된 상태에 가까운 배열로 만들어 놓은 다음에 마지막으로 단순 삽입 정렬을 수행하여 정렬하는 것이 더 효율적입니다. 셸 정렬을 사용하면 정렬을 해야하는 횟수는 늘지만 전체적으로 요소 이동의 횟수가 줄어들어 더 효율적으로 동작합니다. 이와 같은 셸 정렬을 간단한 코드로 작성하면 다음과 같습니다.
    
    ```c
    void shell(int a[], int n)
    {
        int j;
        for(int h = n / 2; h >0; h /= 2)
        {
            for(int i = h; i < n; ++i)
            {
                int tmp = a[i];
                for(j = i - h; j >= 0 && a[j] > tmp; j -=h)
                    a[j + h] = a[j];
                a[j + h] = tmp;
            }
        }
    }
    ```
    
    셸 정렬을 실행할 때 h값을 정해주는 것이 중요한데, h값이 서로의 배수가 되지 않도록 설정해야 합니다. h값이 서로의 배수가 되면 서로 요소가 섞이지 않아서 셸 정렬을 실행하는 의미가 없습니다. h의 값은 3(n + 1)이 되도록 설정해야 하고, h의 초깃값은 배열의 요소 개수를 9로 나눈 값을 넘지 않도록 설정해야 합니다. 따라서 위의 코드를 더 효율적으로 정리한 코드는 다음과 같습니다.
    
    ```c
    void shell(int a[], int n)
    {
    	int j, h;
    	for(h = 0; h < n / 9; h = h * 3 + 1);
    	for(; h > 0; h /= 3)
    		for(int i = 0; i < n; ++i)
    		{
    			int tmp = a[i];
    			for(j = i - h; j >- 0 && a[j] > tmp; j -= h)
    				a[j + h] = a[j];
    			a[j + h] = tmp;
    		}
    }
    ```
    

## 퀵 정렬

> 퀵 정렬은 가장 빠른 알고리즘 중의 하나로 널리 사용됩니다.
> 

- 기본적인 퀵 정렬
    
    퀵 정렬은 키 값 중에서 하나의 값을 선택해서 배열을 두 개의 그룹으로 나눕니다. 이렇게 선택된 키 값을 피벗(pivot)이라고 하고, 피벗은 어느 쪽 그룹에 설정되어도 상관이 없습니다. 피벗을 정하고 나면, 피벗보다 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 이동시킵니다. 요소의 이동은 두 쪽 모두에서 해당하는 값(피벗보다 더 크거나 작은 값)이 발견되었을 때 발생되고, 결과적으로 어느 순간이 지나면 피벗보다 작은 값을 찾는 변수는 피벗보다 큰 값을 발견하게 되고 피벗보다 큰 값을 찾는 변수는 피벗보다 작은 값을 발견하게 됩니다. 이러한 논리로 퀵 정렬을 실행할 때, 그룹의 요소가 하나가 된다면 정렬이 완료되었다고 말할 수 있습니다. 따라서 결론적으로 그룹의 개수가 하나일 때 정렬을 종료하게 되면 퀵 정렬이 완료됩니다. 이 정렬은 하나의 알고리즘을 반복해서 실행하는 구조이기 때문에 재귀 호출을 사용해서 구현할 수 있습니다.
    
    ```c
    #define swap(type, x, y) do { type t = x; x = y; y = t; } while(0)
    
    void quick(int a[], int left, int right)
    {
        int pl = left, pr = right;
        int x = a[pl + pr / 2];
        do {
            while(a[pl] > x) ++pl;
            while(a[pr] < x) --pr;
            if(pl <= pr)
            {
                swap(int, a[pl], a[pr]);
                ++pl;
                --pr;
            }
        } while(pl <= pr);
    
        if(left < pr) quick(a, left, pr);
        if(pl < right) quick(a, pl, right);
    }
    ```
    
    그러나 재귀 호출은 스택 오버 플로를 발생시킬 가능성이 있기 때문에 비재귀적 호출을 사용하여 작성하는 것이 조금 더 안전합니다. 따라서 위의 코드를 비재귀적 함수로 변환하면 다음과 같습니다.
    
    ```c
    #include <stdio.h>
    #include <stdio.h>
    #include <stdlib.h>
    
    #define swap(type, a, b) do{ type tmp = a; a = b; b = tmp; }while(0)
    
    typedef struct {
    	int max;
    	int ptr;
    	int *stk;
    } IntStack;
    
    int Initialize(IntStack *s, int max)
    {
    	s->ptr = 0;
    	if ((s->stk = calloc(max, sizeof(int))) == NULL) {
    		s->max = 0;
    		return -1;
    	}
    	s->max = max;
    	return 0;
    }
    
    int Push(IntStack *s, int x)
    {
    	if (s->ptr >= s->max)
    		return -1;
    	s->stk[s->ptr++] = x;
    	return 0;
    }
    
    int Pop(IntStack *s, int *x)
    {
    	if (s->ptr <= 0)
    		return -1;
    	*x = s->stk[s->ptr--];
    	return 0;
    }
    
    int Peek(const IntStack *s, int *x)
    {
    	if (s->ptr <= 0)
    		return -1;
    	*x = s->stk[s->ptr - 1];
    	return 0;
    }
    
    void Clear(IntStack *s)
    {
    	s->ptr = 0;
    }
    
    int Capacity(const IntStack *s)
    {
    	return s->max;
    }
    
    int Size(const IntStack *s)
    {
    	return s->ptr;
    }
    
    int IsEmpty(const IntStack *s)
    {
    	return s->ptr <= 0;
    }
    
    int IsFull(const IntStack *s)
    {
    	return s->ptr >= s->max;
    }
    
    int Search(const IntStack *s, int x)
    {
    	int i;
    
    	for (i = s->ptr - 1; i >= 0; i--)
    		if (s->stk[i] == x)
    			return i;
    	return -1;
    }
    
    void Print(const IntStack *s)
    {
    	int i;
    
    	for (i = 0; i < s->ptr; i++)
    		printf("%d ", s->stk[i]);
    	putchar('\n');
    }
    
    void Terminate(IntStack *s)
    {
    	if (s->stk != NULL)
    		free(s->stk);
    	s->max = s->ptr = 0;
    }
    
    void quick(int a[], int left, int right)
    {
        IntStack lstack;
        IntStack rstack;
    
        Initialize(&lstack, right - left + 1);
        Initialize(&rstack, right - left + 1);
    
        Push(&lstack, left);
        Push(&rstack, right);
    
        while(!IsEmpty(&lstack))
        {
            int pl = (Pop(&lstack, &left), left);
            int pr = (Pop(&rstack, &right), right);
            int x = a[(left + right) / 2];
            
            do {
                while(a[pl] > x) ++pl;
                while(a[pr] < x) --pr;
                if(pl <= pr)
                {
                    swap(int, a[pl], a[pr]);
                    ++pl;
                    --pr;
                }
            } while(pl <= pr);
            
            if(left < pr)
            {
                Push(&lstack, left);
                Push(&rstack, pr);
            }
            if(pl < right)
            {
                Push(&lstack, pl);
                Push(&rstack, right);
            }
       }
       Terminate(&lstack);
       Terminate(&rstack);
    }
    ```
    
    위의 코드에서는 비재귀적 코드를 구현하기 위해서 스택을 생성해서 데이터를 임시 저장합니다. quick()함수에서 사용하는 스택은 다음 2개 입니다.
    
    1. lstack : 나눌 범위의 왼쪽 끝 요소의 인덱스를 저장하는 스택
    2. rstack : 나눌 범위의 오른쪽 끝 요소의 인덱스를 저장하는 스택
    
    두 스택의 용량은 right - left + 1(나눌 배열의 요소 개수)입니다. 
    

## 병합 정렬

> 병합 정렬은 배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음 병합하는 작업을 반복하여 정렬을 수행하는 알고리즘입니다.
> 

- 정렬을 마친 배열의 병합
    
    정렬을 바친 두 배열의 병합(merge)를 하기 위해서는 각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업을 반복하여 정렬을 마치는 배열을 만듭니다.따라서 두 배열 a = {2, 4, 6, 8, 11, 13}와 b = {1, 2, 3, 4, 9, 16, 21}를 새로운 배열 c에 저장한다고 가정해보겠습니다. 배열 a, b, c를 스캔할 때 쓰는 요소를 pa, pb, pc라고 하면 a[pa]와 b[pb]를 비교하여 작은 값을 c[pc]에 넣으면 됩니다. pa나 pc의 값이 맥스가 되면 해당 작업을 종료하고 맥스 값이 되지 않은 배열을 c에 붙여넣기 하면 됩니다.
    
    ```c
    int a[] = {2, 4, 6, 8, 11, 13};
    int b[] = {1, 2, 3, 4, 9, 16, 21};
    int sizeofa = sizeof(a) / sizeof(int);
    int sizeofb = sizeof(b) / sizeof(int);
    int sizeofc = sizeofa + sizeofb;
    int c[sizeofc];
    int pa = 0, pb = 0, pc = 0;
    while(pa < sizeofa || pb < sizeofb)
        c[pc++] = (a[pa] <= b[pb]) ? a[pa++] : b[pb++];
    while(pa < sizeofa)
        c[pc++] = a[pa++];
    while(pb < sizeofb)
        c[pc++] = b[pb++];
    for(int i = 0; i < sizeofc; ++i)
        printf("%d\t", c[i]);
    ```
    

- 병합 정렬
    
    정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘을 병합 정렬법이라고 합니다. 병합 정렬법을 사용하기 위해서는 배열을 두 부분으로 나누고 각각 정렬한 다음에 병합하면 배열 모두를 정렬할 수 있습니다. 병합 정렬의 알고리즘의 순서를 정리하면 다음과 같습니다.
    
    1. 배열의 앞부분을 병합 정렬로 정렬합니다.
    2. 배열의 뒷부분을 병합 정렬로 정렬합니다.
    3. 배열의 앞부분과 뒷부분을 병합합니다.
    
    그에 따른 간단한 예제는 다음과 같습니다.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    static int *buff;
    
    static void __mergesort(int a[], int left, int right)
    {
        if(left < right)
        {
            int center = (left + right) / 2;
            int i, p = 0, j = 0, k = left;
            __mergesort(a, left, center);
            __mergesort(a, center + 1, right);
            for(i = left; i < center; ++i)
                buff[p++] = a[i];
            while(i <= right && j < p)
                a[k++] = (buff[j] <= a[i]) ? buff[j++] : a[i++];
            while(j < p)
                a[k++] = buff[j++];
        }
    }
    
    int MergeSort(int a[], int n)
    {
        if((buff = calloc(n, sizeof(int))) == NULL) return -1;
        __mergesort(a, 0, n - 1);
        free(buff);
        return 0;
    }
    
    int main()
    {
        int i, nx;
        int *x;
        printf("병합 정렬\n요소 개수 : ");
        scanf("%d", &nx);
        x = calloc(nx, sizeof(int));
    
        for(int i = 0; i < nx; ++i)
        {
            printf("x[%d] : ", i);
            scanf("%d", &x[i]);
        }
    
        MergeSort(x, nx);
        printf("오름차순으로 정렬했습니다.\n");
        for(int i = 0; i < nx; ++i)
            printf("%d\t", x[i]);
        
        free(x);
        
        return 0;
    }
    ```
    
    병합 정렬은 서로 떨어져 있는 요소를 교환하는 것이 아니므로 안정적인 정렬 방법이고, 전체 시간 복잡도는 O(n log n) 입니다.
    

## 힙 정렬

> 선택 정렬을 응용한 알고리즘인 힙 정렬(heap sort)은 힙의 특성을 잏용하여 정렬을 수행합니다.
> 

- 힙의 특성
    
    힙은 부모의 값이 자식의 값보다 항상 크다 는 조건을 만족하는 완전이진트리입니다. 힙에서 부모와 자식 관계는 일정하지만 형제 사이의 대소 관계는 일정하지 않습니다. 힙의 요소를 저장하는 과정은 가장 위 쪽에 있는 루트를 배열 a의 첫 번째 요소에 넣고, 한 단계 아래 요소를 왼쪽에서 오른쪽으로 따라가면서 인덱스의 값을 1씩 늘립니다. 이 규칙에 따라서 힙의 요소를 배열에 저장하면 부모와 자식의 인덱스 사이에 다음과 같은 관계가 성립합니다.
    
    1. 부모는 a[(i - 1) / 2]
    2. 왼쪽 자식은 a[i * 2 + 1]
    3. 오른쪽 자식은[i * 2 + 2]

- 힙 정렬
    
    따라서 힙 정렬은 가장 큰 값이 루트에 위치하는 특성을 이용한 알고리즘입니다. 힙에서 가장 큰 값인 루트를 꺼내는 작업을 반복하고 그 값을 늘어놓으면 배열은 정렬을 마치게 됩니다. 따라서 정렬은 다음의 상태를 반복함으로써 이뤄집니다.
    
    1. 립에서 루트인 10을 꺼냅니다.
    2. 비어있는 루트 위치로 힙의 마지막 요소(오른 쪽 아래 끝에 있는 자식 요소)를 옮깁니다.
    3. 루트로 이동시킨 요소를 올바른 위치로 보내기 위해서 힙의 조건에 따라서 부모와 자식의 위치를 조정합니다. 이 때, 자식과 바꾸는 위치는 큰 값으로 바꿉니다.
    4. 그러면 트리의 가장 아래부분에 다시 1이 이동하게 되고 가장 큰 값이 위로 올라오게 됩니다.
    
    이제 이 힙을 사용하여 힙 정렬 알고리즘으로 확장하면 됩니다. 따라서 힙 정렬은 아래와 같은 과정으로 이뤄지게 됩니다.
    
    1. 변수 i의 값을 n - 1로 초기화합니다.
    2. a[0]와 a[i]를 바꿉니다.
    3. a[0], a[1], … , a[i - 1]을 힙으로 만듭니다.
    4. i의 값을 하나씩 줄여 0이 되면 끝납니다. 그렇지 않으면 2로 돌아갑니다.
    
    그러나 이 때에 항상 초기 상태의 배열이 힙 상태가 아닐 수도 있기 때문에 이 과정을 적용하기 전에 배열을 힙 상태로 만들어 줍니다. 배열을 힙으로 만들기 위해서는 가장 작은 부분부터 힙으로 확장하면 됩니다. 힙 정렬은 선택 정렬을 응용하여 만든 알고리즘입니다. 단순 선택 정렬에서는 가장 큰 요소를 항상 다시 구해야 하지만 힙 정렬에서는 첫 요소를 꺼내는 것만으로 가장 큰 값이 구해지므로 단순 선택 정렬에서 가장 큰 요소를 선택할 때의 시간 복잡도 O(n)을 O(1)로 줄일 수 있습니다. 그러나 힙 정렬에서 다시 힙으로 만드는 작업의 시간 복잡도는 O(log n)이므로, 힙 정렬은 O(n log n)을 갖게 됩니다. 간단한 힙 정렬 프로그램을 마들면 다음과 같습니다.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define swap(type, a, b) do{ type tmp = a; a = b; b = tmp; }while(0)
    
    static void downheap(int a[], int left, int right)
    {
        int tmp = a[left];
        int child, parent;
        for(parent = left; parent < (right + 1) / 2; parent = child)
        {
            int cl = parent * 2 + 1;
            int cr = cl + 1;
            child = (cr <= right && a[cr] > a[cl] ? cr : cl);
            if(tmp >= a[child]) break;
            a[parent] = a[child];
        }
        a[parent] = tmp;
    }
    
    void heapsort_p(int a[], int n)
    {
        for(int i = (n - 1) / 2; i >= 0; --i)
            downheap(a, i, n - 1);
        for(int i = n - 1; i > 0; --i)
        {
            swap(int, a[0], a[i]);
            downheap(a, 0, i - 1);
        }
    }
    
    int main()
    {
        int i, nx;
        int *x;
        printf("힙 정렬\n 요소 개수 : ");
        scanf("%d", &nx);
        x = calloc(nx, sizeof(int));
        for(int i = 0; i < nx; ++i)
        {
            printf("x[%d} : ", i);
            scanf("%d", &x[i]);
        }
    
        heapsort_p(x, nx);
        printf("오름차순으로 정렬했습니다.\n");
        for(int i = 0; i < nx; ++i)
    
            printf("%d\t", x[i]);
    
        free(x);
        return 0;
    }
    ```
    
    downheap()함수를 통해서 a[left] ~ a[right]의 요소를 힙 상태로 만드는 함수입니다. a[left]이외에는 전부 힙 상태라고 가정하고 a[left]을 아랫부분의 알맞은 위치로 옮겨 힙 상태를 만듭니다. 이 때, heapsort()함수는 downheap()함수를 사용하여 배열 a를 힙으로 만들고 루트(a[0])에 있는 가장 큰 값을 빼내어 배열 마지막 요소와 바꾸고 배열의 나머지 부분을 다시 힙으로 만드는 작업을 반복합니다.
    

## 도수 정렬

> 도수 정렬은 요소의 대소 관계를 판단하지 ㅇ낳고 빠르게 정렬할 수 있는 알고리즘입니다.
> 

- 기본적인 도수 정렬
    
    지금까지의 정렬 알고리즘은 두 요소의 키 값을 비교해야 했습니다. 그러나 도수 정렬은 요소를 비교할 필요가 없다는 특징이 있습니다. 도수 정렬 알고리즘은 도수분포표 작성, 누적도수분포표 작성, 목적 뱅려 만들기, 배열 복사의 4단계로 이루어집니다.
    
    1. 도수 분포표 만들기
        
        배열 a = {5, 7, 0, 2, 4, 10, 3, 1, 3}를 바탕으로 각 점수에 해당하는 값이 몇 명인지 나타내는 도수 분포표를 작성합니다. 이를 위해서 배열 f[10] = { 0 }을 새로 만들어 줍니다. 그리고 나서 배열 a에 있는 값에 해당하는 배열의 요소를 1씩 증가시킵니다. 예를 들어서 a[0]은 5이므로 f[5] = 1이 됩니다. 이 작업이 완료되면 f[11] = {1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 1}이 됩니다.
        
    2. 누적 도수 분포표 만들기
        
        도수 분포표를 바탕으로 0에서 n까지의 점수가 몇 개 있는지 누적된 값을 나타내는 도수 분포표를 만들어 보겠습니다. 이것은 다음과 같은 과정으로 이뤄집니다.
        
        ```c
        for(int i = 0; i < 12; ++i)
        	f[i] += f[i - 1];
        ```
        
    3. 목적 배열 만들기
        
        각각의 점수를 받은 값이 몇 번째인지 알 수 있으므로 이 시점에서 정렬은 거의 끝났습니다. 남은 작업은 배열의 각 요솟값과 누적 도수 분포표 f를 대조하여 정렬을 마친 배열을 만드는 작업입니다. 이 작업을 위해서 배열 a와 같은 크기를 갖는 배열 b[8]을 만들어줍니다. 이제 a 배열의 해당하는 값을 b배열의 해당하는 위치에 넣으면 됩니다. 예를 들어서 a[7] = 3이므로 3의 f값을 확인해봅니다. f[3] = 5이므로, a[7]은 b[4]에 들어갑니다. 중복하는 값이 존재할 수 있기 때문에 f[3]의 값에서 1을 빼줍니다. 이러한 방식으로 작성하면 a[5] = 3의 위치는 b[3]으로 자연스럽게 들어갑니다.
        
    4. 배열 복사하기
        
        마지막으로 배열 b를 배열 a로 옮기면 작업이 끝납니다.
        
    
    도수 정렬은 if문 없이 for문만을 사용해 정렬할 수 있습니다. 다음은 간단한 도수 정렬 프로그램입니다.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <time.h>
    
    void fsort(int a[], int n, int max)
    {
        int *f = calloc(max + 1, sizeof(int));
        int *b = calloc(n, sizeof(int));
    
        for(int i = 0; i <= max; ++i) f[i] = 0;
        for(int i = 0; i < n; ++i) f[a[i]]++;
        for(int i = 0; i <= max; ++i) f[i] += f[i - 1];
        for(int i = n - 1; i >= 0; --i) b[--f[a[i]]] = a[i];
        for(int i = 0; i < n; ++i) a[i] = b[i];
    
        free(b);
        free(f);
    }
    
    int main()
    {
        int nx, max = 0;
        int *x;
    
        printf("도수 정렬\n요소 개수 : ");
        scanf("%d", &nx);
    
        x = calloc(nx, sizeof(int));
    
        srand(time(NULL));
        for(int i = 0; i < nx; ++i)
        {
            x[i] = rand() % 100;
            printf("%d\t", x[i]);
            if(i % 9 == 0 && i != 0) printf("\n");
        }
    
        printf("\n");
    
        for(int i = 0; i < nx; ++i)
            max = (x[max] >= x[i]) ? max : i;
    
        fsort(x, nx, x[max]);
        for(int i = 0; i < nx; ++i)
        {
            printf("%d\t", x[i]);
            if(i % 9 == 0 && i != 0) printf("\n");
        }
    
        printf("\n");
    
        free(x);
    
        return 0;
    }
    ```
    
    각 단게에서 배열 요소를 건너뛰지 않고 순서대로 스캔하기 때문에 같은 값의 순서가 바뀌지 않기 때문에 이 정렬은 안정적입니다. 그러나, 목적 배열 만들기의 단계에서 배열 a를 스캔할 때 마지막 위치가 아닌 처음 위치부터 스캔하게 되면 같은 값의 순서가 역순으로 바뀌어 비안정적인 정렬이 됩니다. 또한, 도수 정렬 알고리즘은 데이터의 비교, 교환 작업이 없으므로 매우 빠르고 단일 for문만을 사용하기 때문에 아주 효율적인 알고리즘입니다.
    

- 오름차순과 내림차순
    
    오름차순(ascending order) : 키 값이 작은 데이터를 앞 쪽에 놓는 정렬
    
    내림차순(descending order) : 키 값이 큰 데이터를 앞 쪽에 놓는 정렬
    
- 단순 정렬의 시간 복잡도
    
    단순 정렬은 시간 복잡도가 모두 O(n^2)으로 좋지 않습니다. 따라서 시간 복잡도를 낮추기 위한 개선 방법이 필요합니다.
    
- int a = (x, y);
    
    a에는 y값이 대입됩니다. 이러한 문법을 사용하는 이유는 x에서의 계산식 등이 완료된 후에 y를 대입하기 위해서 사용합니다. 예를 들어서 x가 함수라서 y값을 변화시키는 어떤 작업을 한다면 y값에 변화가 생긴 뒤에 y를 a에 대입하게 됩니다.
    
- 완전이진트리
    
    트리의 가장 윗부분을 루트(root)라고 합니다. 그리고 상하 관계를 부모(parent)와 자식(child)라고 하고 자식관의 관계는 형제(sibling)이라고 합니다. 완전이진트리란 트리의 한 종류로 완전은 부모는 자식을 왼쪽부터 추가하는 모양을 유지한다는 뜻이고 이진은 부모가 가질 수 있는 자식의 개수는 최대 2개라는 뜻입니다.