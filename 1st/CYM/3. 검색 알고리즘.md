# 3. 검색



### 검색 알고리즘

> 데이터 집합이 있을 때 검색에 사용할 알고리즘은 계산 시간이 짧은 알고리즘을 선택하면 된다. 그러나 데이터 집합에 대한 검색뿐 아니라 데이터의 추가, 삭제 등을 자주하는 경우라면 검색 이외의 작업에 소요되는 비용을 종합적으로 평가하여 알고리즘을 선택해야 한다.

- 검색과 키

  - 어떤 검색을 하게 되더라도 특정 항목에 주목한다는 점은 '검색하기'의 공통점

    - ex) 국적이 한국인 사람을 찾는다. (특정 항목 : 국적)
  - 그 항목을 '키'라고 함
- 배열에서 검색하기 (p96)
  - 선형 검색 : 무작의로 늘어놓은 데이터 모임에서 검색
  - 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
  - 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
    - 체인법(해시법) : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
    - 오픈 주소법 : 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법



### 선형 검색

> 요소가 직선 모양으로 늘어선 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색한다.

- 선형 검색의 종료 조건
  - 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우 (검색 실패)
  - 검색할 값과 같은 요소를 발견한 경우 (검색 성공)

```c
#include <stdio.h>
#include <stdlib.h>

int search(const int a[], int n, int key)
{
    int i = 0;				// search 함수는 배열 a의 처음부터 끝까지 n개의 요소를 대상으로 값이
    while(1) {				// key인 요소가 여러 개 존재한다면 반환값은 검색 과정에서 처음 발견한
        if(i == n)			// 요소의 인덱스가 된다. 값이 key인 요소가 존재하지 않으면 -1을 반환
            return -1;
        if(a[i] == key)
            return i;
        i++;
    }
}

int main(void)
{
    int i, nx, ky, idx;
    int *x;
    puts("선형 검색");
    printf("요소 개수 : ");
    scanf("%d", %nx);
    x = calloc(nx, sizeof(int));
    for(i = 0; i < nx; i++){
        printf("x[%d] : ", i);
        scanf("%d", &x[i]);
    }
    printf("검색값 : ");
    scanf("%d", &ky);
    idx = search(x, nx, ky);
    if(idx == -1)
        puts("검색에 실패했습니다.");
    else
        printf("%d는 x[%d]에 있습니다.\n", ky, idx);
    free(x);
    
    return 0;
}
```



#### 선형 검색 - 보초법

> 선형검색은 반복할 때마다 다음의 종료조건을 체크함. 단순한 판단이지만 모이면 데이터 사용량이 커진다. 이 비용을 반으로 줄이는 방법이 보초법이다.

- 검색하고자 하는 키값을 배열을 맨 끝에 저장하는데, 이때 저장하는 값을 보초(sentinel)라고 함
- 원하는 값이 원래의 데이터에 존재하지 않아도 보초가 검색되면 종료됨.
  - 즉, 원하는 키값을 찾지 못 했을 때의 종료조건이 필요가 없다.
    - 원시적으로 생각하면 if문 하나가 줄는 효과가 있는 것이다!

```c
#include <stdio.h>
#include <stdlib.h>

int search(int a[], int n, int key)
{
    int i = 0;
    a[n] = key;				// 보초
    while(1) {
        if(a[i] == key)		// if(i == n)이 필요가 없다
            break;
        i++;
    }
    return i == n ? -1 : i;
}

int main(void)
{
    int i, nx, ky, idx;
    int *x;
    puts("선형 검색(보초법)");
    printf("요소 개수 : ");
    scanf("%d", &nx);
    x = calloc(nx + 1, sizeof(int));
    for(i = 0; i < nx; i++) {
        printf("x[%d] : ", i);
        scanf("%d". &x[i]);
    }
    printf("검색값 : ");
    scanf("%d", &ky);
    idx = search(x, nx, ky);
    if(idx == -1)
        puts("검색에 실패했습니다.");
    else
        printf("%d는 x[%d]에 있습니다.\n", ky, idx);
    free(x);
    
    return 0;
}
```



### 이진 검색

> 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘.

- 데이터가 키 값으로 이미 정렬되어있음. 이진 검색은 선형 검색보다 좀 더 빠르게 검색할 수 있다는 장점 존재.
  - ex) 이진 검색을 이요하여 요소가 10개인 int형 배열 안에서 숫자 37을 찾는다
    - 10개의 요소는 오름차순(내림차순)으로 정렬된다.
