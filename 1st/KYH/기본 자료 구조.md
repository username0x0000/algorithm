# 기본 자료 구조

## 배열

> 기본적이고 간단한 자료 구조인 배열을 살펴보겠습니다.
> 

- 가장 기본적인 배열 선언
    
    ```c
    int a[5] = {1, 2, 3, 4, 5}; // int형 5개의 배열 선언
    int b[] = {1. 2. 3. 4. 5, 6} // int형 6개의 배열 선언
    ```
    
- 메모리 할당기간과 동적 객체 생성 (by calloc(); malloc();, free();)
    
    ```c
    int n;
    a[n] = {0}; // 오류 발생
    ```
    
    위와 같이 코드를 작성하면 배열의 개수가 변수로 설정되어 있어서 오류가 발생합니다. 이렇게 변수로 선언을 해주고 싶다면 동적 객체를 생성하여 배열을 만들어야 합니다. 또한 이렇게 선언된 함수는 확보 메모리가 불필요해질 때 그 공간을 해제해야 하기 때문에 free();함수를 통해서 해재해야 합니다.
    
    ```c
    int array_size;
    int Idata_size = sizeof(int);
    int Mdata_size = 1000;
    int *a = calloc(array_size, Idata_size); // Cdata_size 크기가 array_size의 개수만큼 생성
    int *b = malloc(Mdata_size); // Mdata_size 크기만큼을 할당
    free(a); // a영역 할당 해제
    free(b); // b영역 할당 해제
    ```
    
    포인터(메모리 주소)는 간접 연산자 *을 사용해서 접근할 수 있습니다. 이러한 방식을 통해서 calloc()함수나 malloc()함수를 통해서 만들어낸 공간도 배열처럼 활용할 수 있습니다.
    
    포인터의 자료형은 포인터가 가리키는 곳의 객체 자료형을 따라가기 때문에 포인터 p가 어떤 객체를 가르킬 때는 다음과 같이 작성할 수 있습니다.
    
    ```c
    p = &a; // &연산자를 통해서 a의 주소값을 받아오고 그것을 다시 p에 대입
    ```
    
    포인터의 자료형이 위와 같이 객체의 자료형을 따라가기 때문에 어떤 배열 a에 있는 3번째 원소 a[3]의 자료형은 배열 a의 자료형과 같습니다. 이 때 배열과 마찬가지의 방식으로 포인터에 접근하기 위한 처리 방식은 다음과 같습니다.
    
    ```c
    *(p + i) == p[i]
    *(p - i) == p[-i]
    ```
    
- 공백 포인터 (null ptr. NULL)
    
    객체 포인터, 함수 포인터와는 다른 특별한 포인터 입니다. 정수 0은 모든 포인터 형으로 변환이 가능하고 그 결과는 NULL 포인터 입니다. 이러한 공백 포인터 상수를 매크로 NULL이라고 하고, NULL의 정의는 0 값을 갖는 모든 정수, 상수 또는 상수식을 void*로 형 변환한 식입니다.
    
- 배열 요소의 최대값 구하기
    
    ```c
    int a[3] = {3, 7, 5};
    int max = a[0];
    max = (a[1] > max) ? a[1] : max;
    max = (a[2] > max) ? a[2] : max;
    ```
    
    이러한 방식으로 우리가 살펴볼 요소의 인덱스에 하나씩 뒤 쪽으로 이동하면서 비교하는 방식으로 가장 큰 수를 찾습니다. 이러한 방식으로 배열의 요소를 하나씩 차례대로 살펴보는 과정을 알고리즘 용어로 주사(traverse)라고 합니다.
    
    C언어에서 함수의 선언을 할 때, 매개변수의 배열은 배열이 아니라 함수의 포인터를 넘겨받는 것과 같습니다. 따라서 어떤 배열 a[n]을 넘겨받는 매개변수인 const int a[]는 const int *a와 같습니다. 여기서 매개변수를 const값으로 받는 이유는 const형은 값을 변환할 수 없기 때문에 함수 안에서 의도치 않게 데이터를 변경하는 위험성을 줄이기 위함입니다. 그리고 이 때, 전달받은 인수는 포인터이지 배열이 아니기 때문에 배열의 요소 개수는 새로운 매개변수로 전달받아야 합니다.
    
- 배열의 순서 변경
    
    ```c
    int n = 10;
    int *a = calloc(n, sizeof(int));
    a= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    for(int i = 0; i < n / 2; ++i)
    {
    	int t = a[i];
    	a[i] = a[n - i - 1];
    	a[n - i - 1] = t;
    }
    free(a);
    ```
    
- 두 값의 교환
    
    배열의 역순 정렬은 요소 교환이 총 갯수의 절반만큼 필요합니다.
    
- 기수 변환
    
    > 기수란 n진수에서 n을 의미합니다. 에를 들어 10진수의 기수는 10입니다. 기수 변환이란 10진수 정수를 n진수 정수로 변환하는 것을 의미합니다. 이러한 동작을 하기 위해서는 정수를 n으로 나눈 난머지를 구하는 동시에 그 몫에 대해 나눗셈을 반복하고 몫이 0이 되면 멈춘 뒤에 나머지를 거꾸로 늘여놓아야 합니다.
    > 
    
    ```c
    int card_convr(unsigned x, int n, card d[])
    {
    	char dchar[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // 기수 변환을 할 배열 선언
    	int digits = 0; // 자릿수
    	if (x == 0)
    		d[digits] = dchar[0]; // x가 0이면 변환 후에도 0 
    	else
    	{
    		d[++digits] = dchar [x % n]; // 자리수 (digit)을 하나씩 증가시켜 가면서 dchar에 있는 숫자로 대입
    		x /= n; // n으로 나눈 값을 x에 대입
    	}
    	return digits;
    }
    ```
    
    위의 함수를 사용하게 되면 자리수는 digtis을 통해서 int 자료형으로 반환받고, 입력한 수는 해당 배열 내에서 직접적으로 바뀌게 된다.
    
- 소수의 나열
    
    ```c
    for(int i = 2; i < 1000; ++i)
    {
    	for(int j = 2; j < i; ++j)
    	{
    		if(i % j == 0)
    			break;
    	}
    	printf("%d\n", i);
    }
    ```
    
    위와 같은 방식은 연산의 수가 너무 많기 때문에 비용이 너무 큽니다. 따라서 해당 수 이하의 소수로만 나누어도 소수인지 아닌지 확인이 가능하기 때문에 구한 소수를 저장하는 배열을 추가로 생성하는 방식으로 연산의 비용을 줄일 수 있습니다. 그러나 이러한 방식은 메모리를 더 많이 사용하게 됩니다.
    
    ```c
    int prime_n[500] = { 0 };
    for(int i = 2; i < 1000; ++i)
    {
    	for(int j = 0; prime_n[j] != 0; ++j)
    	{
    		if(i % prime_n[j] == 0)
    			break;
    	}
    	printf("%d\n", i);
    }
    ```
    
    또 다른 개선 방식은 어떤 정수의 제곱근 n’ 이하의 소수로 나누어떨어지지 않는다면 그 이상의 수로도 나누어 떨어지지 않는다는 것을 알 수 있습니다. 이 때 컴퓨터는 제곱근을 구하는 방식보다 제곱을 구하는 방식이 더 비용이 적기 때문에 소수의 제곱과 정수의 크기를 비교하는 알고리즘으로 구현하면 됩니다.
    
    ```c
    int prime_n[500] = { 0 };
    for(int i = 2; i < 1000; ++i)
    {
    	for(int j = 0; prime_n[j] * prime_n[j] <= i 0; ++j)
    	{
    		if(i % prime_n[j] == 0)
    			break;
    	}
    	printf("%d\n", i);
    }
    ```
    
- 다차원 배열
    
    > 배열을 요소로 하는 배열
    > 
    
    지금까지의 배열을 1차원 배열이라고 할 때, 1차원 배열을 요소로 갖는 배열을 2차원 배열이라고 하고, 2차원 배열을 요소로 갖는 배열을 3차원 배열이라고 합니다.
    
    ```c
    int *a[3]; // 2차원 배열
    int b1[3] = {1, 2, 3};
    int b2[3] = {4, 5, 6};
    int b3[3] = {7, 8, 9};
    a[1] = b1;
    a[2] = b2;
    a[3] = b3;
    // 위와 아래의 결과는 같습니다.
    a[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
    ```
    
- 구조체
    
    > 구조체는 임의의 데이터를 다시 조합하여 만드는 자료구조입니다.
    > 
    
    ```c
    struct xyz {
    	int x;
    	double y;
    	long z;
    };
    typedef struct xyz = XYZ;
    
    typedef struct {
    	int x;
    	double y;
    	long z;
    } XYZ;
    
    int main()
    {
    	struct xyz data1;
    	XYZ *data1_p = &data1;
    	data1.x = 3;
    	data1_p->x = 5;
    	XYZ x[] = { {1, 2, 3}, {4, 5, 6} };
    }
    ```
    

- 매크로 함수
    
    위의 함수와 같은 코드는 상당히 짧은 함수이기 때문에 매크로 함수로 아래와 같이 선언할 수도 있습니다.
    
    ```c
    #define swap (type, x, y) do{ type t = x; x = y; y = t;) while(0) // 매크로 함수 선언
    int main()
    {
    	int n = 10;
    	int *a = calloc(n, sizeof(int));
    	a= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    	for(int i = 0; i < n / 2; ++i)
    	{
    		swap(int, a[i], a[n - i - 1]);
    	}
    	free(a);
    }
    ```
    
    매크로 함수에서 따로 ;을 작성하지 않는 이유는 더 자연스러운 가독성을 위해서 사용합니다. 만약에 ;을 포함해서 작성하게 되면 swap(int, a, b);와 같은 방식으로 작성할 때 오류가 발생하게 됩니다. 이처럼 C언어에서의 자연스러운 문법을 이용하여 작성하였을 때 오류가 발생하는 방식은 사용자에게 권할 수 없기 때문에 ;을 작성하지 않고 매크로 함수를 작성합니다. 또한 이러한 방식으로 작성하기 위해서 일부러 do{}while()안에 함수를 작성하는 것이 권장됩니다.
    
- C언어의 메모리 구조
    - 데이터 영역 : 전연 변수와 정적 변수가 할당되는 영역 , 프로그램을 시작하면 할당하고, 프로그램을 종료하면 메모리에서 해제
    - 스택 영역 : 함수 호출시 생성되는 지역 변수와 매개변수가 저장되는 영역, 함수 호출이 완료되면 메모리에서 해제
    - 힙 영역 : 필요에 따라 동적으로 메모리를 할당할 수 있는 영역, 프로그램이 실행되는 동안(run time)에 결정해야 하는 영역이다.
    
    > 힙 영역의 경우 다른 영역을 할당하고 남은 공간이 설정되기 때문에 다른 영역이 다 할당되고 난 이후인 run time 이내에 결정되게 됩니다.
    > 
    
- 보이드 포인터
    
    > 보이드 포인터란 모든 형의 객체를 가르킬 수 있는 포인터 자료형입니다. void포인터를 사용하면 모든 자료형의 포인터에 대입할 수 있고, 반대로 모든 자료형의 포인터 값을 void포인터로 대입할 수 있습니다.
    > 
    
- 난수를 통한 배열의 요소 입력
    
    ```c
    #include <time.h>
    #include <stdio.h>
    #include <stdlib.h>
    
    int main()
    {
    	int number = 100;
    	int height = calloc(number, sizeof(int));
    	srand(time(NULL));
    	for(int i = 0; i < number]; ++i)
    	{
    		height[i] = rand() % 100; // 0 ~ 100까지의 난수를 대입
    	}
    	free(height);
    }
    ```
    
    - 난수를 생성하는 rand 함수가 반환하는 값은 0이상 RAND_MAX이하의 값입니다. 이 때, <stdlib.h> 헤더에 정의된 RAND_MAX 값은 컴퓨터의 환경에 따라 다릅니다. 만약에 seed값을 주지 않고 난수를 발행하게 되면 항상 같은 수가 출력됩니다. (rand()함수 안의 난수가 발행되는 값에는 규칙이 있습니다.) 그러나 seed를 주고 변경을 할 경우에는 seed값에 따라서 항상 다른 값이 출력되게 됩니다. 이 때 seed값을 주기 위해서 사용되는 함수가 srand()함수이고 보통 이 안에 시간을 넣어서 매번 새로운 무작위 난수를 생성합니다.
    - C언어에서 rand()함수가 생성하는 난수는 의사 난수입니다. 이사 난수란 난수처럼 보이지만 일정한 규칙에 따라 생성되는 수를 말합니다. 의사 난수를 통해서 난수를 생성하게 되면 다음에 생성할 난수를 예측할 수 있습니다. 진짜 난수의 경우 다음 값을 예측할 수 없지만 컴퓨터에서는 진짜 난수를 발행할 수 없기 때문에 항상 의사 난수만 발행할 수 있습니다. 이에 따라 항상 새로운 난수를 생성하기 위해서 time(NULL)을 seed로 제공합니다. 현재 시간은 항상 바뀌기 때문에 항상 새로운 난수를 생성할 수 있습니다.