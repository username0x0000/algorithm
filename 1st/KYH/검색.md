# 검색

## 검색 알고리즘

- 검색과 키
    1. 배열 검색
        
        무작위로 늘여놓은 데이터 모임에서 검색 수행
        
    2. 선형 리스트 검색
        
        일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
        
    3. 이진검색트리 검색
        
        추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
        
        (체인법, 오픈 주소법)
        

## 선형 검색

> 요소가 직선 모양으로 늘어선 배열에서 내가 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색하는 알고리즘
> 
- 선형 검색 알고리즘의 경우의 수
    1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
    2. 검색할 값과 같은 요소를 발견한 경우
    
    ```c
    int linear_searching(const int a[], int end_index, int key)
    {
    	for(int i = 0; i < end_index; ++i)
    	{
    		if(a[i] == key)
    			return i;
    	}
    	return -1;
    }
    ```
    
    a[i]가 key값과 같아진 순간 해당 요소의 배열 순서를 반환, 만약에 끝까지 발견하지 못했다면 -1을 반환하는 코드입니다.
    
- 보초법
    
    선형 검색은 반복할 때마다 1, 2를 모두 체크해서 비용이 많이 들어갑니다. 이러한 비용을 줄이기 위한 방법이 보초법입니다. 보초법은 찾을 배열의 끝에 내가 찾을 키 값을 넣는 방법입니다. 이에 따라서 반복 횟수를 반으로 줄여서 코드가 더 적은 비용으로 작동될 수 있도록 할 수 있습니다.
    

## 이진 검색

> 전체 데이터가 키 값으로 이미 정렬(sort)되어 있을 때 사용할 수 있는 검색 방식, 선형 검색보다 조금 더 빠르다.
> 
- 기본적인 알고리즘
    
    오름차순 또는 내림차순으로 정렬된 데이터에서 중간값을 가져와서 그 값과 키 값을 비교한다. 그리고 값이 존재하지 않는 영역을 제외한 뒤에 다시 중간값을 가져와서 그 값과 키 값을 비교하는 방식으로 점점 범위를 좁혀서 내가 원하는 요소가 찾아질 때까지 반복한다.
    
- bsearch()함수
    
    > C언어의 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch()함수barta를 제공합니다. 이 함수를 일반 유틸리티 함수라고 부릅니다.
    > 
    
    ```c
    void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void*));
    ```
    
    base가 가르키는 요소의 개수가 nmemb개이고 요소의 크기가 size인 객체의 배열에서 key와 일치하는 요소를 검색합니다. 이 때, compar는 함수의 포인터로 프로그램이 실행중일 때 어떤 함수를 호출할지 설정해야 합니다. 만약에 호출되는 함수의 자료형이 void*이 아니라면 캐스팅 해주어야 합니다. 가리키는 비교 함수 func()는 key객체에 대한 포인터를 첫 번째 인수로, 배열 요소에 대한 포인터를 두 번째 인수로 하여 호출합니다. func()함수의 반환값은 key객체보다 작으면 음수를, 일치하면 0을, 크면 1을 반환하도록 작성해야 합니다. compar가 가리키는 배열은 항상 key객체와 비교 가능한 작은 요소, 같은 요소, 큰 요소 세 부분의 순서로 존재해야 합니다.
    
    작업을 마치면 검사하는 대상 중에 일치하는 요소에 대한 포인터를 반환하고, 일치하는 요소가 없다면 NULL포인터를 반환합니다. 두 요소의 값이 같을 때 어느 요소와 비교했는지는 반환하지 않습니다.
    
    구조체에서 bsearch()함수를 사용해서 검사하기 위해서는 다음과 같은 형태로 코드를 작성해야 합니다.
    
    ```c
    typedef struct {
    	int x;
    	double y;
    	long z;
    } XYZ;
    
    int XYZ_cmp(const XYZ *x, const XYZ *y)
    {
        return (x->x > y->y) ? 1 : (x->x < y->y) ? -1 : 0;
    }
    
    int main()
    {
    	XYZ x[] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12} };
    	int x_size = sizeof(XYZ) / sizeof(XYZ[0]);
        XYZ key, *result;
        result = bsearch(&key, x, x_size, sizeof(XYZ), (int(*)(const void *, const void *))XYZ_cmp);
        if(realloc == NULL)
            printf("failed");
        else
            printf("x[%d] : %d, %d, %d". p->x, p->x, (int)p->y, (int)p->z);
    }
    ```
    

- 비용
    
    검색만 하면 된다면 계산 시간이 짧은 알고리즘을 선택하면 되지만 검색 이외의 추가, 삭제 등을 자주하는 경우라면 검색 이외의 작업에 소요되는 비용을 종합적으로 평가하여 알고리즘을 선택해야 합니다. 예를 들어, 학생의 이름순대로 배열한 반에서 한 명이 전학을 올 경우, 번호를 중간에 넣어야 해서 다른 데이터를 모두 뒤로 밀어넣어야 합니다. 이러한 방식을 데이터의 추가 비용이 많이 든다고 합니다.
    
- 복잡도
    
    프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러등의 조건에 따라서 달라집니다. 이 때 알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도라고 합니다. 복잡도의 요소는 다음과 같습니다.
    
    - 시간 복잡도 : 실행에 필요한 시간을 평가한 것
        
        시간 복잡도는 해당 줄이 몇 번 실행되었는지 판단합니다. 한 번만 실행되는 경우의 복잡도는 Order(1)로 표기하고, 여러 번 실행되는 경우에는 O(n)으로 표기합니다. (n은 n/2나 n/3등이 되어도 바뀌지 않습니다. n이 무한대로 발산한다고 가정했을 때 그 값의 차이가 무의미해집니다) 이 때, n이 점점 커지면 계산 시간은 O(n)에 비레해서 점점 커지지만, O(1)에 필요한 시간은 변하지 않습니다. 일반적으로 O(f(n)) + O(g(n)) = O(max(f(n), g(n)))의 방식으로 계산합니다. 2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은 쪽의 복잡도를 우선시 합니다. 따라서 전체 복잡도는 가장 높은 차원의 복잡도를 따라갑니다.
        
    - 공간 복잡도 : 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
    
    복잡도의 대소 관계는 다음과 같습니다.
    
    | 작다 |  |  |  | 크다 |
    | --- | --- | --- | --- | --- |
    | 1 | log(n) | n log(n) | n ^ k | 2 ^ n |
- 함수의 포인터
    
    ```c
    type func(type1, type2, … );
    type (*func) (type1, type2, … ) func_p = &func(type1, type2, … );
    (*func_p)(a, b, ...);
    ```
    
    함수의 포인터를 받아오는 자료형으로써 함수의 반환형, 인자의 개수, 인자의 자료형이 일치해야 합니다.  프로그램 실행 중에 호출하는 함수를 변경할 필요성이 생길 때 이런 방식으로 코드를 작성합니다.